function [berS,blerS,berS_canal,blerS_canal,lag]= sistemaFMOFDM(sim)
% Script de un sistema OFDM con modulación en frecuencia. En este script se
% estudian los efectos de cada imperfección por separado.

N0 = 0; CFO = 0; PN = 0; CH=0; OFFSET=0; 
%% Definición de las variables

% -------------------------------------------------------------------------
% Extracción de datos del objeto

blockErSim = sim.blockErSim;                % Número de bloques erróneos a simular
SNR = sim.iSNR;                             % SNR del canal
modo = sim.modo;                            % Modulación usada
speedKMH = sim.speedKMH;                    % Velocidad en Km/h
tau = sim.tau;                              % Perfil de retardos del canal
pdb = sim.pdb;                              % Perfil de amplitudes del canal
efecto = sim.efecto;                        % Tipo de efecto añadido
codificar = sim.codificar;                  % Uso (1) o no (0) de codificacion
Nd = sim.Nd;                                % Número de subportadoras de datos
Nsc = sim.Nsc;                              % Longitud de la FFT
Nsb = sim.Nsb;                              % Número de símbolos por bloque
Npb = sim.Npb;                              % Número de símbolos con pilotos por bloque
k0  = sim.k0;                               % Subportadora de corte
fc = sim.fc;                                % Frecuencia de la portadora
sampleR = sim.sampleR;                      % Frecuencia de muestreo
m = sim.m;                                  % Índice de modulación
longCP = sim.longCP;                        % Vector de longitudes del prefijo cíclico
longCAZAC = sim.longCAZAC;                  % Vector de longitudes del CAZAC
tipo = sim.tipo;                            % Si se introducen los efectos juntos o separados
normalizar = sim.normalizar;                % Si se aplica normalización o no
wdwSync = sim.wdwSync;                      % Nº de bloques de la ventana inicial de sincronización
cpMargin = sim.cpMargin;                    % Margen de muestras que se escogen del CP (25%)
posPil = sim.posPil;                        % Posiciones de los pilotos
valPil = sim.valPil;                        % Valores de los pilotos
delay = sim.delay;                          % Retardo absoluto
sinc = sim.sinc;                            % Uso de sincronismo (1) o no (0).
Nssb = sim.Nssb;                            % Número de símbolos simulados por bloque
dft = sim.dft;                              % Indica si se usa o no la DFT
eq_type=sim.eq_type;                        % Indica el tipo de equalización en el caso de que se utilice
ventanaCP=sim.ventanaCP;                    % Tamaño de la ventana para compensación del OFFSET de Sincronismo. 
% -------------------------------------------------------------------------
% Relacionadas con la informacion (bits tx, bloques tx y erroneos, BER y BLER)

bitTotal = 0;                               % Bits totales enviados
bitTotal_cod = 0;                           % Bits totales codificados enviados
BitEr_canal = 0;                            % Bits erróneos sin codificación
BitEr=0;                                    % Bits erróneos con codificación
nblocks = 0;                                % Nº bloques transmitidos
nblocks_min = 0;                            % Nº mínimo de bloques a transmitir
BlockER_canal=0;                            % Bloques erróneos antes de decodificar
berS_canal=0;                               % BER de canal (sin codificación)
blerS_canal=0;                              % BLER de canal (sin codificación)
BlockER=0;                                  % Bloques erróneos despues de decodificar
berS=0;                                     % BER de canal (con codificación)
blerS=0;                                    % BLER de canal (con codificación)
longB_phy = blockgen(modo,Nd,Nsb-Npb);      % Tamaño del bloque físico contenido en portadoras de datos
juntos = strcmp(tipo,'juntos');             % Logical que es 1 cuando se introducen todos los efectos
lag = zeros(blockErSim,1);

% Cálculo del CAZAC
if longCAZAC ~= 0
    CAZAC = lteZadoffChuSeq(25,longCAZAC);
    CAZAC = repmat(CAZAC,1,Nssb);
else
    CAZAC = [];
end

% Ajuste de las variables de efecto para eliminar los strings

if max(strcmp(efecto,'CH'))
    CH=1;
end
if max(strcmp(efecto,'CFO'))
    CFO=1;
end
if max(strcmp(efecto,'PN'))
    CH=1;
end
if max(strcmp(efecto,'OFFSET'))
    OFFSET=1;
end
if max(strcmp(efecto,'N0'))
    N0=1;
end

    
    

% -------------------------------------------------------------------------
% Relacionadas con los efectos que se introducen
Foff=0;
Pot_PN=0;
Offset_Sync=0;
if CFO || juntos
    Foff = 7.5e3; % Offset de frecuencia del CFO
end
if PN || juntos
    Pot_PN = GenerarPotenciaPN(fc); % Potencia del ruido de fase
end
if CH || juntos
    [chan, nblocks_min] = rayChanGen(fc,sampleR,speedKMH,tau,pdb);
end

if OFFSET || juntos
   Offset_Sync=10;
end
                       
%% Sistema

SNR

% -------------------------------------------------------------------------
% Simulación

Nt = Nsc+longCP+longCAZAC;          % Longitud total del símbolo
Ncp = Nsc+longCP;                   % Longitud sin CAZAC

% if sinc
%     % ETAPA DE SINCRONIZACIÓN
%     disp('FASE DE SINCRONIZACIÓN');
%     disp('----------------------');
%     mLagEst = zeros(wdwSync,Nssb);
%     for ind=1:wdwSync
%         % -----------------------------------------------------------------
%         %                              TRANSMISOR             
% 
%         % Generación del bloque OFDM a transmitir
%         dPm=FMOFDMtransFreq(sim,longB_phy,0,0);
%         % Cálculo de la frecuencia instantánea
%         tF = calcFrec(dPm,Nsc,m,normalizar);
%         % Construcción de la fase instantánea
%         tP = calcFase(tF);
%         % Generación de la señal discreta y en banda base
%         tS_d_aux = exp(1i.*tP);
%         % Adición del prefijo cíclico
%         tS_d = introCP(tS_d_aux,longCP);
%         % Adición del CAZAC
%         tSp = introCAZAC(tS_d,CAZAC);
%         % Conversor P/S
%         tS = reshape(tSp,Nssb*Nt,1);
% 
%         % -----------------------------------------------------------------
%         %                                CANAL   
% 
%         % Introducción del efecto pertinente
%         if efecto == CFO || juntos
%             tS = introCFO(tS,Foff,sampleR);
%         end
%         if efecto == PN || juntos
%             tS = introPN(tS,Pot_PN);
%         end
%         if efecto == CH || juntos
%             tS = filter(chan,tS);
%         end
% 
%         % Adición de ruido Gaussiano
%         rS_n = awgn(tS,SNR);  
% 
%         % Retardar la señal
%         rS_n = delaySignal(rS_n,delay,Nssb);
% 
%         % -----------------------------------------------------------------
%         %                               RECEPTOR                               
% 
%         % Conversor S/P
%         rSp = reshape(rS_n,Nt,Nssb);
%         % Estimación de los retardos usando el CAZAC
%         mLagEst(ind,:) = estLagZC(rSp, CAZAC);
% 
%         fprintf(1,[num2str(ind), ' ']);
%     end
% 
%     % Calculo el valor que más se repite en la ventana de sincronización
%     vLagEst = reshape(mLagEst,wdwSync*Nssb,1);
%     lagEst = mode(vLagEst);
% 
% 
%     fprintf(1,['\nSincronización en el instante ',num2str(lagEst),'\n\n']);
% end

% ETAPA DE RECEPCIÓN DE DATOS
disp('FASE DE RECEPCIÓN DE DATOS');
disp('--------------------------');
varBlockER = 0;
mLagEst = zeros(wdwSync,Nssb);
if(nblocks_min>2000)
    nblocks_min=2000;
end
while (varBlockER<blockErSim || nblocks < nblocks_min)

    % -----------------------------------------------------------------
    %                              TRANSMISOR             
    
    % Generación del bloque OFDM a transmitir
    [dPm,dSt,dS,bitTotal,bitTotal_cod]=FMOFDMtransFreq(sim,longB_phy,bitTotal,bitTotal_cod);
    % Cálculo de la frecuencia instantánea
    tF = calcFrec(dPm,Nsc,m,normalizar);
    % Construcción de la fase instantánea
    tP = calcFase(tF);
    % Generación de la señal discreta y en banda base
    tS_d_aux = exp(1i.*tP);
    % Adición del prefijo cíclico
    tS_d = introCP(tS_d_aux,longCP);
    % Adición del CAZAC
    tSp = introCAZAC(tS_d,CAZAC);
    % Conversor P/S
    tS = reshape(tSp,Nssb*Nt,1);
        
    % -----------------------------------------------------------------
    %                                CANAL   

    % Introducción del efecto pertinente
    if CFO || juntos
        tS = introCFO(tS,Foff,sampleR);
    end
    if PN || juntos
        tS = introPN(tS,Pot_PN);
    end
    if CH || juntos
        tS=filter(chan,tS')';
    end
    
    if OFFSET || juntos
        tS=introOFFSET_SYNC(tS, Offset_Sync);
    end

    % Adición de ruido Gaussiano
    rS_n = awgn(tS,SNR);

    % Retardar la señal
    if sinc
        rS_n = delaySignal(rS_n,delay,Nssb);
    end

    % -----------------------------------------------------------------
    %                               RECEPTOR                               

    % Conversor S/P
    rSp_n = reshape(rS_n,Nt,Nssb);
    if sinc
%         % Estimación de los retardos usando el CAZAC
%         iLags = estLagZC(rSp_n, CAZAC);
%         mLagEst(mod(nblocks,wdwSync)+1,:) = iLags;
%         if mod(nblocks,wdwSync) == 0 && nblocks > 0
%             vLagEst = reshape(mLagEst,wdwSync*Nsb,1);
%             lagEst = mode(vLagEst);
%         end
        % Apunto al comienzo del símbolo
        rS = rS_n(lagEst:end-(Nt-lagEst)-1,:);
        rSp = reshape(rS,Nt,Nsb);
    else
        rSp = rSp_n;
    end
    % Eliminación del CAZAC
    rS_d_aux = elimCAZAC(rSp,length(CAZAC));
    
    %% Introducir y compensar offset de sincronismo (si efecto == 'offset')
    % 1. introducir un offset en la señal, según un nº muestras configurable n_off que indican el retardo introducido 
    % 2. eliminar el prefijo, contando como comienzo de símbolo el instante inicial estimado + longCP - ventanaCP, donde ventanaCP es una ventana configurable 
    % 3. desplazar la respuesta al impulso según h[n + n_off - ventanaCP], donde h es la respuesta ideal
    % 4. ecualizar con h[n + n_off - ventanaCP]
    %%
    
    % Eliminación del prefijo cíclico (si efecto ~= 'offset')
    
        rS_d = elimCP(rS_d_aux,longCP,cpMargin,Nsc,ventanaCP);
   
    
    %% Ecualización de la señal 
    
        if OFFSET==0&&juntos==0&&CH==1
              h_n_matrix=channel_estimation(chan,Nssb,Nt,sampleR,speedKMH);
              rS_d=channelEq(h_n_matrix,rS_d,Nsc,SNR,eq_type,Nsb);
        elseif CH==0&&juntos==0&&OFFSET==1
               h_n_matrix=[zeros(1,ventanaCP-offset_sync) 1];
               h_n_matrix=repmat(h_n_matrix,[Nsb,1]);
               rS_d=channelEq(h_n_matrix,rS_d,Nsc,SNR,'zfe',Nsb);
        elseif CH==1&&juntos==0&&OFFSET==1||juntos==1
               h_n_matrix=channel_estimation(chan,Nssb,Nt,sampleR,speedKMH);
               h_n_matrix=[zeros(Nsb,ventanaCP-offset_sync) h_n_matrix];
               rS_d=channelEq(h_n_matrix,rS_d,Nsc,SNR,eq_type,Nsb);
        end
    % reconstruir la respuesta al impulso y aplicar ZF/MMSE
    %%

    % Extracción de la fase
    rP = unwrap(angle(rS_d));
    % Recuperación de la frecuencia instantánea
    rF_aux = recFrec(rP);  
%     % Acotación de la señal
%     rF_aux = acotarSignal(rF_aux,m);
    % Recuperación de las portadoras
    rX_freq = calcEspectroFrec(rF_aux,Nsc,m);
    % Cálculo y compensación de la fase progresiva
    if sinc
        [rX_freq,vLag] = estPhaseProg2(rX_freq,valPil,posPil,Nsc,k0,Nd,dft);
        lag(nblocks*Nsb+1:Nsb*(nblocks+1)) = vLag.';
    end
    % Realizo el procesamiento de la señal recibida (eq, demod...)
    [dSr,dSr_dec]=FMOFDMrecepFreq(sim,rX_freq); 
    
    
    nblocks = nblocks+1;
    
    % ---------------------------------------------------------------------
    % Cálculos de BER y BLER
    
    %BER/BLER antes de decodificar
    bitsRx = dSr<0;
    nErrors = sum(bitsRx ~= dSt);
    BitEr_canal = BitEr_canal + nErrors;
    flagBlockER = nErrors > 0;

    if codificar
        berS_canal = BitEr_canal/bitTotal_cod;
    else
        berS_canal = BitEr_canal/bitTotal;
    end

    if flagBlockER
        BlockER_canal=BlockER_canal+1;
        if ~codificar
            fprintf(1,[num2str(BlockER_canal), ' ']);
        end
    end
    blerS_canal= BlockER_canal/nblocks;

    % BER/BLER después de decodificar
    if codificar
        nErrors = sum(dSr_dec ~= dS);
        BitEr = BitEr + nErrors;
        flagBlockER = nErrors > 0;

        berS = BitEr/bitTotal;

        if flagBlockER
            BlockER=BlockER+1;
%             fprintf(1,[num2str(BlockER), ' ']);
        end
        blerS= BlockER/nblocks;
    end
    
    % ---------------------------------------------------------------------
    % Control de ejecución

    % Cambio la variable de iteración del bucle en función de si se aplica
    % codificación
    if codificar
        varBlockER = BlockER;
    else
        varBlockER = BlockER_canal;
    end
    
    % Fichero de estado de ejecución
    if mod(nblocks,500)==0
        results = [berS_canal,blerS_canal,berS,blerS];
        storeExecResults(sim,results,nblocks,varBlockER);
    end 

end

%% Display de resultados
 
% Resultados numéricos
disp(['Bloques transmitidos: ',num2str(nblocks)]);
if codificar
    disp(['BER: ', num2str(berS),'    BLER: ',num2str(blerS)]);
    disp(['Nº bloques erróneos: ',num2str(BlockER)]);
end
disp(['BER canal: ',num2str(berS_canal),'    BLER canal: ',num2str(blerS_canal)]);
disp(['Nº bloques canal erróneos: ',num2str(BlockER_canal)]);


end